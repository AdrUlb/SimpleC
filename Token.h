#pragma once
#include "SourceFile.h"
#include "Util/Managed.h"
#include "Util/Span.h"
#include "Util/String.h"

#define TOKEN_ENUM_VALUES \
	X(TOKEN_EOF) \
	X(TOKEN_UNEXPECTED) \
	X(TOKEN_WHITESPACE) \
	X(TOKEN_COMMENT_SINGLELINE) \
	X(TOKEN_COMMENT_MULTILINE) \
	\
	X(TOKEN_LITERAL_INTEGER) \
	X(TOKEN_LITERAL_FLOAT) \
	X(TOKEN_LITERAL_CHAR) \
	X(TOKEN_LITERAL_STRING) \
	\
	X(TOKEN_IDENTIFIER) \
	\
	\
	X(TOKEN_KEYWORD_CHAR) \
	X(TOKEN_KEYWORD_DOUBLE) \
	X(TOKEN_KEYWORD_FLOAT) \
	X(TOKEN_KEYWORD_INT) \
	X(TOKEN_KEYWORD_LONG) \
	X(TOKEN_KEYWORD_SHORT) \
	X(TOKEN_KEYWORD_VOID) \
	\
	X(TOKEN_KEYWORD_CONST) \
	X(TOKEN_KEYWORD_VOLATILE) \
	X(TOKEN_KEYWORD_SIGNED) \
	X(TOKEN_KEYWORD_UNSIGNED) \
	X(TOKEN_KEYWORD_RESTRICT) \
	\
	X(TOKEN_KEYWORD_AUTO) \
	X(TOKEN_KEYWORD_EXTERN) \
	X(TOKEN_KEYWORD_REGISTER) \
	X(TOKEN_KEYWORD_STATIC) \
	X(TOKEN_KEYWORD_TYPEDEF) \
	\
	X(TOKEN_KEYWORD_INLINE) \
	\
	X(TOKEN_KEYWORD_STRUCT) \
	X(TOKEN_KEYWORD_UNION) \
	X(TOKEN_KEYWORD_ENUM) \
	\
	X(TOKEN_KEYWORD_IF) \
	X(TOKEN_KEYWORD_ELSE) \
	X(TOKEN_KEYWORD_SWITCH) \
	X(TOKEN_KEYWORD_CASE) \
	X(TOKEN_KEYWORD_DEFAULT) \
	\
	X(TOKEN_KEYWORD_FOR) \
	X(TOKEN_KEYWORD_DO) \
	X(TOKEN_KEYWORD_WHILE) \
	X(TOKEN_KEYWORD_BREAK) \
	X(TOKEN_KEYWORD_CONTINUE) \
	X(TOKEN_KEYWORD_GOTO) \
	X(TOKEN_KEYWORD_RETURN) \
	\
	X(TOKEN_KEYWORD_SIZEOF) \
	\
	X(TOKEN_PUNCTUATOR_EQUAL)  \
	X(TOKEN_PUNCTUATOR_PLUS) \
	X(TOKEN_PUNCTUATOR_MINUS) \
	X(TOKEN_PUNCTUATOR_ASTERISK) \
	X(TOKEN_PUNCTUATOR_SLASH) \
	X(TOKEN_PUNCTUATOR_PERCENT) \
	X(TOKEN_PUNCTUATOR_AMPERSAND) \
	X(TOKEN_PUNCTUATOR_PIPE) \
	X(TOKEN_PUNCTUATOR_CARET) \
	X(TOKEN_PUNCTUATOR_TILDE) \
	X(TOKEN_PUNCTUATOR_EXCLAMATION) \
	X(TOKEN_PUNCTUATOR_QUESTION) \
	X(TOKEN_PUNCTUATOR_COLON) \
	X(TOKEN_PUNCTUATOR_HASH) \
	X(TOKEN_PUNCTUATOR_LESS) \
	X(TOKEN_PUNCTUATOR_GREATER) \
	X(TOKEN_PUNCTUATOR_PERIOD) \
	X(TOKEN_PUNCTUATOR_COMMA) \
	X(TOKEN_PUNCTUATOR_SEMICOLON) \
	X(TOKEN_PUNCTUATOR_PARENOPEN) \
	X(TOKEN_PUNCTUATOR_PARENCLOSE) \
	X(TOKEN_PUNCTUATOR_BRACEOPEN) \
	X(TOKEN_PUNCTUATOR_BRACECLOSE) \
	X(TOKEN_PUNCTUATOR_BRACKETOPEN) \
	X(TOKEN_PUNCTUATOR_BRACKETCLOSE) \
	X(TOKEN_PUNCTUATOR_DOUBLEQUOTE) \
	X(TOKEN_PUNCTUATOR_SINGLEQUOTE) \
	\
	X(TOKEN_PUNCTUATOR_EQUAL_EQUAL) \
	X(TOKEN_PUNCTUATOR_EXCLAMATION_EQUAL) \
	X(TOKEN_PUNCTUATOR_LESS_EQUAL) \
	X(TOKEN_PUNCTUATOR_GREATER_EQUAL) \
	X(TOKEN_PUNCTUATOR_PLUS_PLUS) \
	X(TOKEN_PUNCTUATOR_MINUS_MINUS) \
	X(TOKEN_PUNCTUATOR_PLUS_EQUAL) \
	X(TOKEN_PUNCTUATOR_MINUS_EQUAL) \
	X(TOKEN_PUNCTUATOR_ASTERISK_EQUAL) \
	X(TOKEN_PUNCTUATOR_SLASH_EQUAL) \
	X(TOKEN_PUNCTUATOR_PERCENT_EQUAL) \
	X(TOKEN_PUNCTUATOR_AMPERSAND_EQUAL) \
	X(TOKEN_PUNCTUATOR_PIPE_EQUAL) \
	X(TOKEN_PUNCTUATOR_CARET_EQUAL) \
	X(TOKEN_PUNCTUATOR_AMPERSAND_AMPERSAND) \
	X(TOKEN_PUNCTUATOR_PIPE_PIPE) \
	X(TOKEN_PUNCTUATOR_LESS_LESS) \
	X(TOKEN_PUNCTUATOR_GREATER_GREATER) \
	X(TOKEN_PUNCTUATOR_MINUS_GREATER) \
	\
	X(TOKEN_PUNCTUATOR_LESS_LESS_EQUAL) \
	X(TOKEN_PUNCTUATOR_GREATER_GREATER_EQUAL) \
	\
	X(TOKEN_MAX)

#define X(name) name,

typedef enum
{
	TOKEN_ENUM_VALUES
} Token_Type;

#undef X

always_inline const char* Token_Type_ToString(const Token_Type type)
{
	switch (type)
	{
#define X(name) case name: return #name;
		TOKEN_ENUM_VALUES
#undef X
		default:
			return "<unknown>";
	}
}

#undef TOKEN_ENUM_VALUES

typedef struct
{
	const char* str;
	const Token_Type type;
} TokenStringMapEntry;

#define FLOATING_POINT_EXONENT_CHAR(isHex) ((isHex) ? 'p' : 'e')

static const TokenStringMapEntry punctuators[] = {
	// Three character punctuators
	{ "<<=", TOKEN_PUNCTUATOR_LESS_LESS_EQUAL },
	{ ">>=", TOKEN_PUNCTUATOR_GREATER_GREATER_EQUAL },
	//3,  Two character punctuators
	{ "==", TOKEN_PUNCTUATOR_EQUAL_EQUAL },
	{ "!=", TOKEN_PUNCTUATOR_EXCLAMATION_EQUAL },
	{ "<=", TOKEN_PUNCTUATOR_LESS_EQUAL },
	{ ">=", TOKEN_PUNCTUATOR_GREATER_EQUAL },
	{ "++", TOKEN_PUNCTUATOR_PLUS_PLUS },
	{ "--", TOKEN_PUNCTUATOR_MINUS_MINUS },
	{ "+=", TOKEN_PUNCTUATOR_PLUS_EQUAL },
	{ "-=", TOKEN_PUNCTUATOR_MINUS_EQUAL },
	{ "*=", TOKEN_PUNCTUATOR_ASTERISK_EQUAL },
	{ "/=", TOKEN_PUNCTUATOR_SLASH_EQUAL },
	{ "%=", TOKEN_PUNCTUATOR_PERCENT_EQUAL },
	{ "&=", TOKEN_PUNCTUATOR_AMPERSAND_EQUAL },
	{ "|=", TOKEN_PUNCTUATOR_PIPE_EQUAL },
	{ "^=", TOKEN_PUNCTUATOR_CARET_EQUAL },
	{ "&&", TOKEN_PUNCTUATOR_AMPERSAND_AMPERSAND },
	{ "||", TOKEN_PUNCTUATOR_PIPE_PIPE },
	{ "<<", TOKEN_PUNCTUATOR_LESS_LESS },
	{ ">>", TOKEN_PUNCTUATOR_GREATER_GREATER },
	{ "->", TOKEN_PUNCTUATOR_MINUS_GREATER },
	// Single character punctuators
	{ "=", TOKEN_PUNCTUATOR_EQUAL },
	{ "+", TOKEN_PUNCTUATOR_PLUS },
	{ "-", TOKEN_PUNCTUATOR_MINUS },
	{ "*", TOKEN_PUNCTUATOR_ASTERISK },
	{ "/", TOKEN_PUNCTUATOR_SLASH },
	{ "%", TOKEN_PUNCTUATOR_PERCENT },
	{ "&", TOKEN_PUNCTUATOR_AMPERSAND },
	{ "|", TOKEN_PUNCTUATOR_PIPE },
	{ "^", TOKEN_PUNCTUATOR_CARET },
	{ "~", TOKEN_PUNCTUATOR_TILDE },
	{ "!", TOKEN_PUNCTUATOR_EXCLAMATION },
	{ "?", TOKEN_PUNCTUATOR_QUESTION },
	{ ":", TOKEN_PUNCTUATOR_COLON },
	{ "#", TOKEN_PUNCTUATOR_HASH },
	{ "<", TOKEN_PUNCTUATOR_LESS },
	{ ">", TOKEN_PUNCTUATOR_GREATER },
	{ ".", TOKEN_PUNCTUATOR_PERIOD },
	{ ",", TOKEN_PUNCTUATOR_COMMA },
	{ ";", TOKEN_PUNCTUATOR_SEMICOLON },
	{ "(", TOKEN_PUNCTUATOR_PARENOPEN },
	{ ")", TOKEN_PUNCTUATOR_PARENCLOSE },
	{ "{", TOKEN_PUNCTUATOR_BRACEOPEN },
	{ "}", TOKEN_PUNCTUATOR_BRACECLOSE },
	{ "[", TOKEN_PUNCTUATOR_BRACKETOPEN },
	{ "]", TOKEN_PUNCTUATOR_BRACKETCLOSE },
	{ "\"", TOKEN_PUNCTUATOR_DOUBLEQUOTE },
	{ "\'", TOKEN_PUNCTUATOR_SINGLEQUOTE },
};

static const TokenStringMapEntry keywords[] = {

	// Keywords: types
	{ "char", TOKEN_KEYWORD_CHAR },
	{ "double", TOKEN_KEYWORD_DOUBLE },
	{ "float", TOKEN_KEYWORD_FLOAT },
	{ "int", TOKEN_KEYWORD_INT },
	{ "long", TOKEN_KEYWORD_LONG },
	{ "short", TOKEN_KEYWORD_SHORT },
	{ "void", TOKEN_KEYWORD_VOID },

	// Keywords: qualifiers
	{ "const", TOKEN_KEYWORD_CONST },
	{ "volatile", TOKEN_KEYWORD_VOLATILE },
	{ "signed", TOKEN_KEYWORD_SIGNED },
	{ "unsigned", TOKEN_KEYWORD_UNSIGNED },
	{ "restrict", TOKEN_KEYWORD_RESTRICT },

	// Keywords: storage classes
	{ "auto", TOKEN_KEYWORD_AUTO },
	{ "extern", TOKEN_KEYWORD_EXTERN },
	{ "register", TOKEN_KEYWORD_REGISTER },
	{ "static", TOKEN_KEYWORD_STATIC },
	{ "typedef", TOKEN_KEYWORD_TYPEDEF },

	// Keywords: function specifiers
	{ "inline", TOKEN_KEYWORD_INLINE },

	// Keywords: structures
	{ "struct", TOKEN_KEYWORD_STRUCT },
	{ "union", TOKEN_KEYWORD_UNION },
	{ "enum", TOKEN_KEYWORD_ENUM },

	// Keywords: control flow
	{ "if", TOKEN_KEYWORD_IF },
	{ "else", TOKEN_KEYWORD_ELSE },
	{ "switch", TOKEN_KEYWORD_SWITCH },
	{ "case", TOKEN_KEYWORD_CASE },
	{ "default", TOKEN_KEYWORD_DEFAULT },

	// Keywords: loops/jumps
	{ "for", TOKEN_KEYWORD_FOR },
	{ "do", TOKEN_KEYWORD_DO },
	{ "while", TOKEN_KEYWORD_WHILE },
	{ "break", TOKEN_KEYWORD_BREAK },
	{ "continue", TOKEN_KEYWORD_CONTINUE },
	{ "goto", TOKEN_KEYWORD_GOTO },
	{ "return", TOKEN_KEYWORD_RETURN },

	// Keywords: operators
	{ "", TOKEN_KEYWORD_SIZEOF },
};

typedef enum
{
	TOKEN_LITERAL_FLOAT_TYPE_DOUBLE,
	TOKEN_LITERAL_FLOAT_TYPE_FLOAT,
	TOKEN_LITERAL_FLOAT_TYPE_LONGDOUBLE,
	TOKEN_LITERAL_FLOAT_TYPE_BINARY16,
	TOKEN_LITERAL_FLOAT_TYPE_BINARY32,
	TOKEN_LITERAL_FLOAT_TYPE_BINARY64,
	TOKEN_LITERAL_FLOAT_TYPE_DECIMAL32,
	TOKEN_LITERAL_FLOAT_TYPE_DECIMAL64,
	TOKEN_LITERAL_FLOAT_TYPE_DECIMAL128,
} Token_LiteralFloat_Type;

typedef enum
{
	TOKEN_LITERAL_INTEGER_TYPE_INT,
	TOKEN_LITERAL_INTEGER_TYPE_LONG,
	TOKEN_LITERAL_INTEGER_TYPE_LONGLONG,
	TOKEN_LITERAL_INTEGER_TYPE_UNSIGNEDINT,
	TOKEN_LITERAL_INTEGER_TYPE_UNSIGNEDLONG,
	TOKEN_LITERAL_INTEGER_TYPE_UNSIGNEDLONGLONG,
} Token_LiteralInteger_Type;

typedef struct
{
	ConstCharSpan value;
	size_t base;
	Token_LiteralInteger_Type type;
} Token_LiteralInteger;

typedef struct
{
	bool isHex;

	bool hasIntegerPart;
	ConstCharSpan integerPart;

	bool hasFractionalPart;
	ConstCharSpan fractionalPart;

	bool hasExponent;
	bool exponentIsNegative;
	ConstCharSpan exponentPart;

	Token_LiteralFloat_Type type;
} Token_LiteralFloat;

typedef struct
{
	ConstCharSpan value;
} Token_LiteralIdentifier;

typedef union
{
	Token_LiteralInteger literalInteger;
	Token_LiteralFloat literalDecimalFloat;
	Token_LiteralIdentifier literalIdentifier;
} Token_Data;

typedef struct
{
	Token_Type type;
	SourceLocation location;
	Token_Data data;
} Token;

#define LIST_TYPE TokenList
#define LIST_ELEMENT_TYPE Token
#include "Util/ListDef.h"
#undef LIST_TYPE
#undef LIST_ELEMENT_TYPE

always_inline Token Token_Create(const Token_Type type, const SourceLocation location, const Token_Data data)
{
	return (Token) {
		.type = type,
		.location = location,
		.data = data,
	};
}

ConstCharSpan Token_LiteralInteger_Get(const Token* token);
void Token_Print(const Token* token);
